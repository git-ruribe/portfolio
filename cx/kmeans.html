<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimizador de Ubicaciones con Plantas Fijas</title>
    
    <!-- Estilos y Librerías -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Cargar Leaflet ANTES que sus plugins -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        #map { 
            height: 70vh; 
            width: 100%;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .leaflet-popup-content-wrapper { background-color: #f9fafb; border-radius: 0.5rem; }
        #plant-settings-container ul { list-style: none; padding: 0; }
        #plant-settings-container li { display: flex; align-items: center; padding: 4px 0; border-bottom: 1px solid #f3f4f6; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Optimizador de Ubicaciones</h1>
            <p class="mt-2 text-lg text-gray-600">Analiza tus puntos de entrega partiendo de una configuración de plantas fijas y móviles.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            
            <div class="lg:col-span-4 bg-white p-6 rounded-lg shadow-lg h-fit">
                <h2 class="text-2xl font-bold mb-4 border-b pb-2">Controles</h2>
                <div class="space-y-4">
                    <div>
                        <label for="csvFile" class="block text-sm font-medium text-gray-700 mb-1">1. Cargar Puntos de Entrega (CSV)</label>
                        <input type="file" id="csvFile" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer"/>
                    </div>
                     <div>
                        <label for="centroidsFile" class="block text-sm font-medium text-gray-700 mb-1">2. Cargar Plantas Actuales (Opcional)</label>
                        <div class="flex items-center space-x-2">
                             <input type="file" id="centroidsFile" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100 cursor-pointer"/>
                             <button id="clearCentroidsBtn" class="p-2 text-gray-400 hover:text-gray-600" title="Limpiar archivo de centroides">&times;</button>
                        </div>
                    </div>
                    
                    <!-- Contenedor para la configuración de plantas -->
                    <div id="plant-settings-container" class="hidden bg-gray-50 p-3 rounded-lg">
                        <h4 class="text-sm font-bold text-gray-800 mb-2">Configurar Plantas</h4>
                        <ul id="plant-list"></ul>
                    </div>

                    <div id="kmeans-params" class="space-y-4 pt-2 border-t">
                         <p class="text-xs text-gray-500 -mb-2">Estos parámetros se usan si no se carga un archivo de plantas.</p>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="kValue" class="block text-sm font-medium text-gray-700">Grupos (K)</label>
                                <input type="number" id="kValue" value="4" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                            </div>
                            <div>
                                <label for="nInitValue" class="block text-sm font-medium text-gray-700">Intentos</label>
                                <input type="number" id="nInitValue" value="10" min="1" max="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                            </div>
                        </div>
                    </div>

                    <div class="pt-2 border-t">
                        <label class="block text-sm font-medium text-gray-700">3. Definir Restricciones</label>
                        <div class="grid grid-cols-2 gap-4 mt-1">
                             <div>
                                <label for="minPoints" class="block text-xs font-medium text-gray-500">Puntos Mín.</label>
                                <input type="number" id="minPoints" value="1" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                            </div>
                            <div>
                                <label for="maxPoints" class="block text-xs font-medium text-gray-500">Puntos Máx.</label>
                                <input type="number" id="maxPoints" value="1000" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                            </div>
                        </div>
                    </div>

                    <button id="analyzeBtn" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-300 flex items-center justify-center">
                        <i class="fas fa-cogs mr-2"></i>
                        Analizar
                    </button>
                </div>
                <div id="message" class="mt-4 text-sm text-center p-2 rounded-md"></div>
            </div>

            <div class="lg:col-span-8">
                 <div id="map"></div>
                 <div class="mt-8 bg-white p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-bold mb-4">Estadísticas del Resultado Final</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cluster</th>
                                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nº de Puntos</th>
                                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Distancia Promedio</th>
                                </tr>
                            </thead>
                            <tbody id="statsTableBody" class="bg-white divide-y divide-gray-200"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        window.onload = function() {
            // --- DATOS SIMULADOS ---
            const simulatedData = [
                { Planta: 'Norte', Latitud: 25.6866, Longitud: -100.3161 }, { Planta: 'Norte', Latitud: 25.7850, Longitud: -100.4100 },
                { Planta: 'Norte', Latitud: 25.6500, Longitud: -100.2900 }, { Planta: 'Norte', Latitud: 25.7200, Longitud: -100.3500 },
                { Planta: 'Norte', Latitud: 25.8000, Longitud: -100.5000 }, { Planta: 'Norte', Latitud: 25.9000, Longitud: -100.6000 },
                { Planta: 'Norte', Latitud: 25.6000, Longitud: -100.2000 }, { Planta: 'Centro', Latitud: 19.4326, Longitud: -99.1332 },
                { Planta: 'Centro', Latitud: 19.3900, Longitud: -99.1700 }, { Planta: 'Centro', Latitud: 19.4500, Longitud: -99.1000 },
                { Planta: 'Centro', Latitud: 19.3500, Longitud: -99.1500 }, { Planta: 'Centro', Latitud: 19.5000, Longitud: -99.2000 },
                { Planta: 'Occidente', Latitud: 20.6597, Longitud: -103.3496 }, { Planta: 'Occidente', Latitud: 20.6700, Longitud: -103.3900 },
                { Planta: 'Occidente', Latitud: 20.6000, Longitud: -103.3000 }, { Planta: 'Occidente', Latitud: 20.7000, Longitud: -103.4000 },
                { Planta: 'Occidente', Latitud: 20.6200, Longitud: -103.3700 }, { Planta: 'Sureste', Latitud: 21.1619, Longitud: -86.8515 },
                { Planta: 'Sureste', Latitud: 20.9674, Longitud: -89.5926 }, { Planta: 'Sureste', Latitud: 21.1300, Longitud: -86.8200 },
                { Planta: 'Sureste', Latitud: 20.8900, Longitud: -89.6200 },
            ].map(d => ({ ...d, lat: d.Latitud, lng: d.Longitud }));

            // --- VARIABLES GLOBALES ---
            let userData = null;
            let initialCentroids = null;
            const kInput = document.getElementById('kValue');
            const nInitInput = document.getElementById('nInitValue');
            const minPointsInput = document.getElementById('minPoints');
            const maxPointsInput = document.getElementById('maxPoints');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const messageDiv = document.getElementById('message');
            const fileInput = document.getElementById('csvFile');
            const centroidsFileInput = document.getElementById('centroidsFile');
            const clearCentroidsBtn = document.getElementById('clearCentroidsBtn');
            const kmeansParamsDiv = document.getElementById('kmeans-params');
            const plantSettingsContainer = document.getElementById('plant-settings-container');
            const plantList = document.getElementById('plant-list');
            let map, markersLayer, arrowsLayer;
            const CLUSTER_COLORS = ['#3b82f6', '#ef4444', '#10b981', '#f97316', '#8b5cf6', '#ec4899', '#f59e0b', '#14b8a6', '#64748b', '#d946ef', '#06b6d4', '#f43f5e'];

            // --- INICIALIZACIÓN ---
            try {
                map = L.map('map').setView([23.6345, -102.5528], 5);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(map);
                markersLayer = L.layerGroup().addTo(map);
                arrowsLayer = L.layerGroup().addTo(map);
            } catch (e) { showMessage('Error al inicializar el mapa: ' + e.message, 'error'); }

            // --- EVENT LISTENERS ---
            analyzeBtn.addEventListener('click', handleAnalysis);
            fileInput.addEventListener('change', (e) => handleFileUpload(e, 'data'));
            centroidsFileInput.addEventListener('change', (e) => handleFileUpload(e, 'centroids'));
            clearCentroidsBtn.addEventListener('click', () => {
                centroidsFileInput.value = '';
                initialCentroids = null;
                kmeansParamsDiv.style.opacity = '1';
                kInput.disabled = false;
                nInitInput.disabled = false;
                plantSettingsContainer.classList.add('hidden');
                plantList.innerHTML = '';
                showMessage('Archivo de centroides iniciales limpiado.', 'info');
            });

            // --- MANEJO DE ARCHIVOS Y UI ---
            function handleFileUpload(event, type) {
                const file = event.target.files[0];
                if (!file) return;
                showMessage('Cargando archivo...', 'loading');
                Papa.parse(file, {
                    header: true, skipEmptyLines: true,
                    complete: (results) => {
                        if (results.errors.length) { showMessage('Error al leer el CSV.', 'error'); return; }
                        if (!results.data.length || !results.data[0].hasOwnProperty('Latitud') || !results.data[0].hasOwnProperty('Longitud')) {
                            showMessage('CSV debe tener columnas "Latitud" y "Longitud".', 'error'); return;
                        }
                        try {
                            const parsedData = results.data.map((row, index) => {
                                const lat = parseFloat(row.Latitud);
                                const lng = parseFloat(row.Longitud);
                                if (isNaN(lat) || isNaN(lng)) throw new Error(`Fila ${index + 2} inválida.`);
                                return { ...row, lat, lng, isFixed: false }; // Añadir isFixed por defecto
                            });

                            if (type === 'data') {
                                userData = parsedData;
                                showMessage(`${userData.length} puntos cargados. Listo para analizar.`, 'success');
                            } else if (type === 'centroids') {
                                initialCentroids = parsedData;
                                kInput.value = initialCentroids.length;
                                kInput.disabled = true;
                                nInitInput.disabled = true;
                                kmeansParamsDiv.style.opacity = '0.5';
                                populatePlantSettings();
                                showMessage(`${initialCentroids.length} centroides iniciales cargados.`, 'success');
                            }
                            handleAnalysis();
                        } catch (error) { showMessage(`Error en datos: ${error.message}`, 'error'); }
                    },
                    error: () => { showMessage('No se pudo procesar el archivo.', 'error'); }
                });
            }

            function populatePlantSettings() {
                plantList.innerHTML = '';
                if (!initialCentroids) {
                    plantSettingsContainer.classList.add('hidden');
                    return;
                }
                initialCentroids.forEach((plant, index) => {
                    const plantName = plant.Nombre || plant.ID || `Planta ${index + 1}`;
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <input type="checkbox" id="plant-fixed-${index}" class="mr-2 h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                        <label for="plant-fixed-${index}" class="text-sm text-gray-700 flex-grow">${plantName}</label>
                    `;
                    li.querySelector(`#plant-fixed-${index}`).addEventListener('change', (e) => {
                        initialCentroids[index].isFixed = e.target.checked;
                    });
                    plantList.appendChild(li);
                });
                plantSettingsContainer.classList.remove('hidden');
            }
            
            // --- LÓGICA DE ANÁLISIS PRINCIPAL ---
            async function handleAnalysis() {
                const dataToAnalyze = userData || simulatedData;
                const minPoints = parseInt(minPointsInput.value, 10);
                const maxPoints = parseInt(maxPointsInput.value, 10);
                let k = parseInt(kInput.value, 10);
                const n_init = parseInt(nInitInput.value, 10);

                if ([minPoints, maxPoints, k, n_init].some(isNaN)) { showMessage('Parámetros inválidos.', 'error'); return; }
                if (minPoints > maxPoints) { showMessage('Mínimo de puntos no puede ser mayor que máximo.', 'error'); return; }

                showMessage('Iniciando análisis...', 'loading');
                await new Promise(resolve => setTimeout(resolve, 50));

                try {
                    // 1. Obtener la agrupación inicial
                    let initialClustering;
                    if (initialCentroids) {
                        k = initialCentroids.length;
                        initialClustering = kmeans(dataToAnalyze, k, initialCentroids);
                    } else {
                        if (k * minPoints > dataToAnalyze.length) { showMessage('No hay suficientes puntos para el mínimo especificado.', 'error'); return; }
                        initialClustering = runNKmeans(dataToAnalyze, k, n_init);
                    }
                    
                    let { clusters, centroids } = initialClustering;

                    // 2. Bucle de estabilización: aplicar restricciones hasta que no haya cambios
                    let maxCycles = 10;
                    let changedInCycle = true;
                    while (changedInCycle && maxCycles > 0) {
                        changedInCycle = false;
                        maxCycles--;

                        // 2a. Re-clusterizar con los centroides actuales para estabilizar asignaciones
                        ({ clusters, centroids } = kmeans(dataToAnalyze, centroids.length, centroids));

                        // 2b. Fusionar clusters pequeños
                        const mergeResult = mergeUndersized(clusters, centroids, minPoints);
                        if (mergeResult.changed) {
                            clusters = mergeResult.clusters;
                            centroids = mergeResult.centroids;
                            changedInCycle = true;
                            showMessage(`Fusionando clusters... Quedan ${clusters.length}`, 'loading');
                            await new Promise(resolve => setTimeout(resolve, 50));
                            continue; // Volver al inicio del bucle para re-estabilizar
                        }

                        // 2c. Dividir clusters grandes (solo si no hubo fusiones)
                        const splitResult = splitOversized(clusters, centroids, maxPoints, n_init);
                        if (splitResult.changed) {
                            clusters = splitResult.clusters;
                            centroids = splitResult.centroids;
                            changedInCycle = true;
                            showMessage(`Dividiendo clusters... Ahora hay ${clusters.length}`, 'loading');
                            await new Promise(resolve => setTimeout(resolve, 50));
                            continue; // Volver al inicio del bucle
                        }
                    }

                    if (maxCycles === 0) { showMessage('Análisis finalizado (límite de ciclos alcanzado).', 'info'); } 
                    else { showMessage(`Análisis estable finalizado. Se generaron ${clusters.length} clusters.`, 'success'); }
                    
                    visualizeResults(clusters, centroids, dataToAnalyze, initialCentroids);

                } catch (error) {
                    showMessage(`Error durante el análisis: ${error.message}`, 'error');
                    console.error("Error details:", error);
                }
            }

            // --- LÓGICAS DE RESTRICCIÓN ---
            function mergeUndersized(clusters, centroids, minPoints) {
                let changed = false;
                let currentClusters = [...clusters];
                let currentCentroids = [...centroids];
                
                const validClusters = [];
                const undersizedClusters = [];

                currentClusters.forEach((c, i) => {
                    if (c.points.length < minPoints && c.points.length > 0) {
                        undersizedClusters.push(c);
                        changed = true;
                    } else if (c.points.length > 0) {
                        validClusters.push(c);
                    }
                });

                if (!changed) return { clusters, centroids, changed: false };
                if (validClusters.length === 0) return { clusters: [], centroids: [], changed: true };

                const pointsToReassign = undersizedClusters.flatMap(uc => uc.points);
                const validCentroidsForReassignment = validClusters.map(c => c.centroid);

                pointsToReassign.forEach(point => {
                    let closestValidClusterIndex = -1;
                    let minSqDist = Infinity;
                    validClusters.forEach((vc, vc_idx) => {
                        const centroid = vc.centroid;
                        const sqDist = (point.lat - centroid.lat)**2 + (point.lng - centroid.lng)**2;
                        if (sqDist < minSqDist) {
                            minSqDist = sqDist;
                            closestValidClusterIndex = vc_idx;
                        }
                    });
                    if (closestValidClusterIndex !== -1) {
                        validClusters[closestValidClusterIndex].points.push(point);
                    }
                });
                
                const finalCentroids = validClusters.map(c => {
                    const newCentroid = c.centroid.isFixed ? c.centroid : calculateCentroid(c.points);
                    return { ...newCentroid, isFixed: c.centroid.isFixed, initialIndex: c.initialIndex };
                });

                return { clusters: validClusters, centroids: finalCentroids, changed: true };
            }

            function splitOversized(clusters, centroids, maxPoints, n_init) {
                let changed = false;
                const finalClusters = [];
                
                clusters.forEach((cluster, i) => {
                    // Solo dividir si es móvil y excede el máximo
                    if (cluster.points.length > maxPoints && !cluster.centroid.isFixed) {
                        changed = true;
                        const splitResult = runNKmeans(cluster.points, 2, n_init);
                        splitResult.clusters.forEach(subCluster => {
                            finalClusters.push({ ...subCluster, initialIndex: cluster.initialIndex });
                        });
                    } else {
                        finalClusters.push(cluster);
                    }
                });

                if (changed) {
                    const finalCentroids = finalClusters.map(c => {
                        const centroid = calculateCentroid(c.points);
                        return { ...centroid, isFixed: false, initialIndex: c.initialIndex };
                    });
                    return { clusters: finalClusters, centroids: finalCentroids, changed: true };
                }

                return { clusters, centroids, changed: false };
            }

            // --- FUNCIONES K-MEANS ---
            function runNKmeans(data, k, n_init, forcedCentroids = null) {
                let bestResult = { clusters: [], centroids: [], inertia: Infinity };
                if (k === 0 || data.length < k) return bestResult;
                const runs = forcedCentroids ? 1 : n_init;
                for (let i = 0; i < runs; i++) {
                    const initialC = forcedCentroids ? forcedCentroids : initializeCentroidsKMeansPP(data, k);
                    const currentResult = kmeans(data, k, initialC);
                    const inertia = calculateInertia(currentResult.clusters, currentResult.centroids);
                    if (inertia < bestResult.inertia) { bestResult = { ...currentResult, inertia }; }
                }
                return bestResult;
            }

            function kmeans(data, k, initialCentroids) {
                const maxIterations = 100;
                let centroids = initialCentroids.map((c, i) => ({ ...c, initialIndex: c.initialIndex ?? i }));
                let assignments = [];

                for (let iter = 0; iter < maxIterations; iter++) {
                    const newAssignments = data.map(point => {
                        let minSqDist = Infinity, closestIndex = 0;
                        centroids.forEach((centroid, index) => {
                            const sqDist = (point.lat - centroid.lat)**2 + (point.lng - centroid.lng)**2;
                            if (sqDist < minSqDist) { minSqDist = sqDist; closestIndex = index; }
                        });
                        return closestIndex;
                    });
                    
                    if (JSON.stringify(assignments) === JSON.stringify(newAssignments)) break;
                    assignments = newAssignments;

                    centroids = centroids.map((oldCentroid, i) => {
                        const clusterPoints = data.filter((_, index) => assignments[index] === i);
                        // Si la planta es fija, no mover su centroide
                        const newCentroid = oldCentroid.isFixed ? oldCentroid : (clusterPoints.length > 0 ? calculateCentroid(clusterPoints) : oldCentroid);
                        return { ...newCentroid, isFixed: oldCentroid.isFixed, initialIndex: oldCentroid.initialIndex };
                    });
                }
                const clusters = centroids.map((c, i) => ({
                    points: data.filter((_, pIndex) => assignments[pIndex] === i),
                    initialIndex: c.initialIndex,
                    centroid: c
                }));

                return { clusters, centroids };
            }
            
            function initializeCentroidsKMeansPP(data, k) {
                const centroids = [];
                if (data.length === 0 || k === 0) return [];
                const dataCopy = [...data];
                centroids.push(dataCopy.splice(Math.floor(Math.random() * dataCopy.length), 1)[0]);
                while (centroids.length < k && dataCopy.length > 0) {
                    const distances = dataCopy.map(point => {
                        let minSqDist = Infinity;
                        centroids.forEach(centroid => {
                            const sqDist = (point.lat - centroid.lat)**2 + (point.lng - centroid.lng)**2;
                            minSqDist = Math.min(minSqDist, sqDist);
                        });
                        return minSqDist;
                    });
                    const sumOfDistances = distances.reduce((a, b) => a + b, 0);
                    if (sumOfDistances === 0) break;
                    const randomValue = Math.random() * sumOfDistances;
                    let cumulativeSum = 0;
                    let nextCentroidIndex = -1;
                    for (let j = 0; j < distances.length; j++) {
                        cumulativeSum += distances[j];
                        if (cumulativeSum >= randomValue) { nextCentroidIndex = j; break; }
                    }
                    if (nextCentroidIndex === -1) { nextCentroidIndex = dataCopy.length - 1; }
                    centroids.push(dataCopy.splice(nextCentroidIndex, 1)[0]);
                }
                return centroids.map(c => ({...c, isFixed: false}));
            }

            function calculateCentroid(points) {
                if (!points || points.length === 0) return { lat: 0, lng: 0 };
                const totals = points.reduce((acc, point) => ({ lat: acc.lat + point.lat, lng: acc.lng + point.lng }), { lat: 0, lng: 0 });
                return { lat: totals.lat / points.length, lng: totals.lng / points.length };
            }

            function calculateInertia(clusters, centroids) {
                let totalInertia = 0;
                clusters.forEach((cluster, i) => {
                    const centroid = centroids[i];
                    if (!centroid || cluster.points.length === 0) return;
                    totalInertia += cluster.points.reduce((sum, point) => sum + ((point.lat - centroid.lat)**2 + (point.lng - centroid.lng)**2), 0);
                });
                return totalInertia;
            }

            // --- VISUALIZACIÓN ---
            function visualizeResults(clusters, centroids, allPoints, originalStartCentroids) {
                markersLayer.clearLayers();
                arrowsLayer.clearLayers();
                displayClusterStats(clusters, centroids);

                if (originalStartCentroids) {
                    originalStartCentroids.forEach((centroid, index) => {
                        const icon = L.divIcon({ html: `<i class="fas fa-industry fa-2x" style="color: #9ca3af;"></i>`, className: 'bg-transparent border-0', iconSize: [30, 30], iconAnchor: [15, 30] });
                        L.marker([centroid.lat, centroid.lng], { icon: icon, zIndexOffset: -100 })
                            .bindPopup(`<b>Inicio Original ${index + 1}</b><br>Lat: ${centroid.lat.toFixed(4)}, Lon: ${centroid.lng.toFixed(4)}`)
                            .addTo(markersLayer);
                    });
                }

                clusters.forEach((clusterData, i) => {
                    const finalCentroid = centroids[i];
                    const color = CLUSTER_COLORS[i % CLUSTER_COLORS.length];
                    
                    clusterData.points.forEach(point => {
                        L.circleMarker([point.lat, point.lng], { radius: 6, color: 'white', weight: 1, fillColor: color, fillOpacity: 0.8 })
                            .bindPopup(`<b>Cluster: ${i + 1}</b><br><hr class="my-1">${Object.keys(point).filter(k=>k!=='lat'&&k!=='lng'&&k!=='isFixed').map(k=>`<b>${k}:</b> ${point[k]}`).join('<br>')}`)
                            .addTo(markersLayer);
                    });
                    
                    if (finalCentroid && finalCentroid.lat !== 0) {
                        const iconHtml = finalCentroid.isFixed ? `<i class="fas fa-lock" style="position: absolute; top: -5px; left: -5px; color: #4b5563; font-size: 0.7em; background: white; border-radius: 50%; padding: 2px;"></i><i class="fas fa-industry fa-2x" style="color: ${color}; text-shadow: 1px 1px 2px white;"></i>` : `<i class="fas fa-industry fa-2x" style="color: ${color}; text-shadow: 1px 1px 2px white;"></i>`;
                        const icon = L.divIcon({ html: iconHtml, className: 'bg-transparent border-0', iconSize: [30, 30], iconAnchor: [15, 30] });
                        L.marker([finalCentroid.lat, finalCentroid.lng], { icon: icon })
                            .bindPopup(`<b>Planta Óptima (Cluster ${i + 1})</b><br>Lat: ${finalCentroid.lat.toFixed(4)}, Lon: ${finalCentroid.lng.toFixed(4)}<br>${finalCentroid.isFixed ? '<b>(FIJA)</b>' : ''}`)
                            .addTo(markersLayer);

                        if (originalStartCentroids && clusterData.initialIndex !== undefined) {
                            const origin = originalStartCentroids[clusterData.initialIndex];
                            if (origin.lat !== finalCentroid.lat || origin.lng !== finalCentroid.lng) {
                                const line = L.polyline([[origin.lat, origin.lng], [finalCentroid.lat, finalCentroid.lng]], { color: '#6b7280', weight: 2, opacity: 0.7 });
                                const arrow = L.polylineDecorator(line, { patterns: [{ offset: '100%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 12, polygon: false, pathOptions: { stroke: true, color: '#6b7280', opacity: 0.7 } }) }] });
                                arrowsLayer.addLayer(line);
                                arrowsLayer.addLayer(arrow);
                            }
                        }
                    }
                });
                if (allPoints.length > 0) map.fitBounds(L.latLngBounds(allPoints.map(p => [p.lat, p.lng])).pad(0.1));
            }
            
            function displayClusterStats(clusters, centroids) {
                const statsTableBody = document.getElementById('statsTableBody');
                statsTableBody.innerHTML = '';
                if (!clusters || clusters.length === 0) {
                    statsTableBody.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-gray-500">No hay datos para mostrar.</td></tr>`;
                    return;
                }
                clusters.forEach((clusterData, i) => {
                    const centroid = centroids[i];
                    const numPoints = clusterData.points.length;
                    let avgDistance = 0;
                    if (numPoints > 0 && centroid) {
                        const totalDistance = clusterData.points.reduce((sum, point) => sum + Math.sqrt((point.lat - centroid.lat)**2 + (point.lng - centroid.lng)**2), 0);
                        avgDistance = totalDistance / numPoints;
                    }
                    const row = `
                        <tr>
                            <td class="px-6 py-4 whitespace-nowrap"><div class="flex items-center text-sm text-gray-900 font-medium">
                                <div class="w-4 h-4 rounded-full mr-3 flex-shrink-0" style="background-color: ${CLUSTER_COLORS[i % CLUSTER_COLORS.length]};"></div>
                                Cluster ${i + 1} ${centroid.isFixed ? '<span class="ml-2 text-xs text-gray-500">(Fijo)</span>' : ''}
                            </div></td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">${numPoints}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">${avgDistance > 0 ? avgDistance.toFixed(4) : 'N/A'}</td>
                        </tr>`;
                    statsTableBody.innerHTML += row;
                });
            }

            function showMessage(text, type) {
                messageDiv.textContent = text;
                messageDiv.className = 'mt-4 text-sm text-center p-2 rounded-md transition-all duration-300 ';
                const styles = { success: 'text-green-800 bg-green-100', error: 'text-red-800 bg-red-100 font-bold', loading: 'text-blue-800 bg-blue-100', info: 'text-yellow-800 bg-yellow-100' };
                messageDiv.classList.add(...(styles[type] || styles.info).split(' '));
            }

            // --- EJECUCIÓN INICIAL ---
            handleAnalysis();
        };
    </script>
</body>
</html>