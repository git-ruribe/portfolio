
    <div class="flex-grow relative">
      <canvas id="velocityChart"></canvas>
    </div>

  </div>

  <script>
    // =========================================================================
    // --- CONFIGURACIÓN ---
    // =========================================================================
    // MQTT
    const brokerUrl = 'wss://89842616873441ce985c09eadcb3ed60.s1.eu.hivemq.cloud:8884/mqtt';
    const mqttOptions = {
      username: 'elmike',
      password: '2WSXqwer',
      clientId: 'velocity-dashboard-' + Math.random().toString(16).slice(3),
    };
    // NUEVO: Dos temas, uno para la sesión y otro para los datos
    const mqttSessionTopic = 'Gym/sessions';
    const mqttDataTopic = 'Gym/data';

    // FÍSICA DEL ENCODER
    const COUNTS_PER_REVOLUTION = 2400; // Conteo 4x para un encoder de 600 PPR
    const WHEEL_CIRCUMFERENCE_CM = 13.85; // Circunferencia en cm para calcular la velocidad lineal

    // GRÁFICA
    const maxDataPoints = 1000;

    // =========================================================================
    // --- ESTADO GLOBAL ---
    // =========================================================================
    let readingIndex = 0;
    let allReadings = [];
    // NUEVO: Objeto para guardar la información de la sesión actual
    let currentSession = {};

    // =========================================================================
    // --- INICIALIZACIÓN DE LA GRÁFICA ---
    // =========================================================================
    const velocityData = {
      labels: [],
      datasets: [{
        label: 'Velocity (cm/s)',
        data: [],
        borderColor: 'rgb(75, 192, 192)',
        backgroundColor: 'rgba(75, 192, 192, 0.2)',
        fill: false,
        tension: 0.1,
      }],
    };
    const chartConfig = {
      type: 'line',
      data: velocityData,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: { title: { display: true, text: 'Reading Index' } },
          y: {
            title: { display: true, text: 'Velocity (cm/s)' },
            beginAtZero: false,
          },
        },
        plugins: {
          legend: { display: true },
          tooltip: {
            callbacks: {
              label: (context) => `Velocidad: ${context.parsed.y.toFixed(2)} cm/s`,
            },
          },
        },
      },
    };
    const ctx = document.getElementById('velocityChart').getContext('2d');
    const velocityChart = new Chart(ctx, chartConfig);

    // =========================================================================
    // --- CLIENTE MQTT Y MANEJO DE EVENTOS ---
    // =========================================================================
    const client = mqtt.connect(brokerUrl, mqttOptions);
    const statusElement = document.getElementById('connectionStatus');

    client.on('connect', () => {
      statusElement.textContent = 'Conectado al Broker MQTT';
      statusElement.className = 'text-lg font-semibold text-green-600';
      
      // NUEVO: Suscribirse a ambos temas
      client.subscribe([mqttSessionTopic, mqttDataTopic], { qos: 0 }, (err) => {
        if (err) {
          console.error('Error de suscripción:', err);
          statusElement.textContent = `Error de suscripción: ${err.message}`;
          statusElement.className = 'text-lg font-semibold text-red-600';
        }
      });
    });

    client.on('error', (err) => {
      console.error('Error MQTT:', err);
      statusElement.textContent = `Error MQTT: ${err.message}`;
      statusElement.className = 'text-lg font-semibold text-red-600';
    });

    client.on('close', () => {
      statusElement.textContent = 'Desconectado del Broker MQTT';
      statusElement.className = 'text-lg font-semibold text-yellow-600';
    });

    // NUEVO: Función para actualizar el panel de información
    function updateSessionPanel() {
        document.getElementById('session-exercise').textContent = currentSession.ejercicio || 'N/A';
        document.getElementById('session-zone').textContent = currentSession.zona || 'N/A';
        document.getElementById('session-sets').textContent = currentSession.sets_config || 'N/A';
        document.getElementById('session-reps').textContent = currentSession.reps_config || 'N/A';
        document.getElementById('session-rest').textContent = currentSession.descanso_config || 'N/A';
        document.getElementById('session-id').textContent = currentSession.session_id || 'N/A';
    }

    // NUEVO: Función para resetear la gráfica y los datos
    function resetChartAndData() {
        readingIndex = 0;
        allReadings = [];
        velocityData.labels = [];
        velocityData.datasets[0].data = [];
        velocityChart.update();
    }

    client.on('message', (topic, message) => {
      try {
        const payload = JSON.parse(message.toString());

        // CAMBIO: Lógica para manejar mensajes de dos temas diferentes
        if (topic === mqttSessionTopic) {
          console.log('Nueva sesión recibida:', payload);
          // Guarda los nuevos datos de la sesión
          currentSession = payload;
          // Resetea la gráfica para empezar de cero con la nueva sesión
          resetChartAndData();
          // Actualiza el panel de información en la pantalla
          updateSessionPanel();

        } else if (topic === mqttDataTopic) {
          // Solo procesa los datos si pertenecen a la sesión actual
          if (!currentSession.session_id || payload.session_id !== currentSession.session_id) {
            return; // Ignora datos de sesiones antiguas o si no hay sesión activa
          }

          if (payload.lecturas && Array.isArray(payload.lecturas)) {
            payload.lecturas.forEach((reading) => {
              const { ts, c, dt } = reading;
              if (typeof c === 'number' && typeof dt === 'number' && dt > 0) {
                // Calcular velocidad lineal en cm/s
                const revolutions = c / COUNTS_PER_REVOLUTION;
                const distance_cm = revolutions * WHEEL_CIRCUMFERENCE_CM;
                const time_s = dt / 1000;
                const velocity = distance_cm / time_s;

                readingIndex++;
                allReadings.push({ ts, c, dt, velocity });

                velocityData.labels.push(readingIndex);
                velocityData.datasets[0].data.push(velocity);

                if (velocityData.labels.length > maxDataPoints) {
                  velocityData.labels.shift();
                  velocityData.datasets[0].data.shift();
                }
                
                velocityChart.update();
              }
            });
          }
        }
      } catch (err) {
        console.error('Error procesando mensaje:', err);
        statusElement.textContent = `Error procesando mensaje: ${err.message}`;
        statusElement.className = 'text-lg font-semibold text-red-600';
      }
    });

    // =========================================================================
    // --- EXPORTACIÓN A CSV ---
    // =========================================================================
    function exportToCsv(filename) {
        if (allReadings.length === 0) {
            alert('No hay datos para exportar.');
            return;
        }

        // CAMBIO: Nuevas cabeceras para el CSV con toda la información
        const headers = 'Timestamp,Counts(c),DeltaTime(dt),Velocity(cm/s),SessionID,Ejercicio,Zona,Sets,Reps,Descanso';

        // CAMBIO: Mapear el nuevo objeto de datos a una fila del CSV, añadiendo los datos de la sesión
        const rows = allReadings.map(d => 
            `${d.ts},${d.c},${d.dt},${d.velocity.toFixed(4)},${currentSession.session_id},${currentSession.ejercicio},${currentSession.zona},${currentSession.sets_config},${currentSession.reps_config},${currentSession.descanso_config}`
        );
        
        const csvContent = [headers, ...rows].join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    document.getElementById('exportButton').addEventListener('click', () => {
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        exportToCsv(`velocity_data_${timestamp}.csv`);
    });
  </script>
</body>
</html>
